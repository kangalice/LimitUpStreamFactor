## 流式字段计算框架

## 项目结构

```shell
./
├── CMakeLists.txt
├── config.json                     # 配置参数文件，包括路径、端口等参数
├── docs                            # 项目文档
├── include                         # 头文件，包括外部库
│   ├── MatchEngineAPI.hpp          # API和SPI接口定义
│   ├── MatchEngineAPIData.hpp      # 数据类型定义
│   ├── MatchEngineAPIStruct.hpp    # 结构体定义
├── python                          # python代码，读取外部数据
│   ├── my_utils.py
├── README.md
├── demo                            # 示例代码
│   ├── Basic.hpp                   # demo中的Basic逻辑代码
│   └── MoneyFlow.cpp               # demo中的MoneyFlow逻辑代码
└──
```

## 编译过程

1. 需要用户从源码编译安装ZMQ(libzmq,cppzmq)，pybind11两个外部库。

2. 编译项目
```shell
mkdir build
cd build
cmake ..
make
```

## 调用方法

1. 直接调用可执行文件：先调用demo，然后调用offline_data，不输入日期默认运行调用当天的撮合，可以通过位置输入两个参数：
```shell
./offline_data [date] [incre_port]
./demo [date] [incre_port]
```
- date: 日期，格式为%Y-%m-%d，不输入默认调用当天。
- incre_port: 端口偏移量，用于多进程同时运行脚本。

## 字段开发说明

框架整体基于事件驱动的回调机制，提供用户进行逐笔的trade/order字段开发的功能。用户需基于MatchEngineAPI.hpp提供的接口名称，实现自己的字段回调类。具体开发与调用逻辑如下：

1. 创建一个接收回报的类，该类继承自MatchEngineSPI，用来接收撮合引擎过程中接收到的逐笔委托和成交。
2. 调用createMatchAPI接口，创建一个API对象，该对象用来启动撮合和和查询盘口。
3. 调用registerSpi接口，将回报接收类对象传进请求类对象中。
4. 调用startMatch接口进行撮合。
5. 每个进程会有其独立的spi对象接口，每个spi只会处理一部分股票数据，在处理数据和进行ob的时候需要注意。

在demo/BaseFactorGenerator.cpp中提供了demo，可以参考进行开发。

## 开发细节说明

1. 上交所的逐笔委托是成交后的剩余量，因此如果要对逐笔委托进行统计，必须要将上交所委托进行还原。受限于交易所的发送逻辑，还原操作放在SPI处进行，demo中已给出还原的代码，如果需要保存还原后的逐笔委托，需要在onBeforeAddOrder和onBeforeAddTrade处均进行处理。框架调整过后，不会再在逐笔委托接口处发送上交所逐笔成交对应的逐笔委托。上交所在集合竞价阶段发送的委托为原始委托，在onBeforeAddTrade中不需要进行还原处理，可用side==N来进行跳过上交所处理逻辑。
2. 市价单的价格字段是没有意义的，深交所的市价单包括本方最优和市价单，上交所没有市价单，处理一些和价格有关的字段时都要考虑到市价单的价格，需要拎出来处理，如果需要还原市价单委托价格，需要在onTrade系列处理函数中进行处理。
3. 集合竞价期间的虚拟成交价通过买卖盘档位揭示，其中买一和卖一都揭示虚拟成交价格和成交数量，买二或卖二揭示虚拟成交价位上的买剩余量或卖剩余量，其余档位无盘口。
4. 算分钟字段的时候，需要注意分钟字段的bar的数量以及对应含义。以一分钟字段为例，bar从9:30到11:30，从13:01一直到收盘15:00，一共有241根bar。所有的bar都是左开右闭，代表当前时间点之前一分钟的数据的统计量，除了下面一些bar比较特殊。第一个bar9:30，代表从开盘集合竞价的所有委托/成交的统计结果，而不是最近一分钟的统计结果；收盘14:58、14:59、15:00这三根bar，代表收盘集合竞价每一分钟的统计量，其中14:58和14:59对应的时间段只有委托发生没有成交，15:00对应的时间段有委托和成交。在计算字段时要注意上面说的比较特殊的几个bar，不同的字段在上述bar的计算逻辑并不相同，要根据具体的字段逻辑在该处计算或者填充合理值。
5. SPI中的两个onFactorOB函数必须实现，分别对应ob一只票和批量ob的场景，两者的逻辑须保持一致。可以考虑在批量ob的函数中循环调用ob一只票的函数。

## 开发格式约定

1. 按照字段逻辑分类组织代码。demo中给出了两类逻辑的分类示例，具体到代码中并非对应的逻辑，仅作为分类示例。具体字段逻辑分类名称请与负责人讨论后确定。
2. 避免复杂的字段逻辑组织。每一个逻辑分类代码，包括了这个逻辑分类下需要的所有内容，包括自定义的结构体、函数等，不要进行复杂的代码逻辑组织，不要新建额外的cpp或者hpp文件，保证字段代码的独立性，尽量维持代码结构的扁平，字段计算逻辑的清晰。
3. 保证代码中与文档中的字段名称对应。每个字段通过成员类属性在代码中保存，名称要与文档中写的字段变量名称保持一致。
4. 字段代码写在src文件夹中。新建一个src文件夹，字段写在该文件夹当中。

## 项目文档规范

用户开发完成字段代码后，需要在docs文件夹中，以markdown文档格式提交以下几个文档：

1. 项目结构文档。该文档用于介绍项目整体结构，文件构成，编译方法和使用方法等，方便使用者快速上手。可以参考本文档中“项目结构”，“编译过程”，“调用方法”等模块，需要有一个下面这样的项目目录说明：

```shell
./
├── CMakeLists.txt
├── config.json                     # 配置参数文件，包括路径、端口等参数
├── docs                            # 项目文档
├── include                         # 头文件，包括外部库
│   ├── MatchEngineAPI.hpp          # API和SPI接口定义
│   ├── MatchEngineAPIData.hpp      # 数据类型定义
│   ├── MatchEngineAPIStruct.hpp    # 结构体定义
├── python                          # python代码，读取外部数据
│   ├── my_utils.py
├── README.md
├── demo                            # 示例代码
│   ├── Basic.hpp                   # demo中的Basic逻辑代码
│   └── MoneyFlow.cpp               # demo中的MoneyFlow逻辑代码
└──
```

2. 字段提交文档。字段文档用于详细介绍说明研究员所写的字段，应包括字段名称、字段说明、频率分类、计算公式、公式说明在内的说明。提交格式为markdown文档，以表格的形式组织字段，计算公式请以latex公式格式书写。**字段名称需与代码中的字段名称相匹配，即代码中要有和”字段名称”一致的变量名，要能够被搜索出来**。以下为一个示例：

| 字段名称 | 因子说明 | 频率分类 | 计算公式 | 公式说明 | source依赖 | 所属逻辑 |
|---|---|---|---|---|---|---|
| order_num | 过去一分钟累计委托笔数 | 1min | $$N_{\text{order}}(t_{n}-t_{n-1})$$ | N代表数量，括号内为统计的时间范围，为这一分钟的时间 | order | Basic |

